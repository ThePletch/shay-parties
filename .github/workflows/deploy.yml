name: Deploy
on:
  workflow_dispatch:
    inputs:
      environment:
        required: true
        type: choice
        # manual deploys to prod will be limited to master by environment rules
        options: [production, staging]
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
    secrets:
      AWS_ECR_ROLE:
        required: true
      AWS_REGION:
        required: true
      AWS_ECR_REPOSITORY:
        required: true
      AWS_ECS_CLUSTER:
        required: true
      AWS_ECS_SERVICE:
        required: true
      DATABASE_USERNAME:
        required: true
      DATABASE_PASSWORD:
        required: true
      DATABASE_HOST:
        required: true
      DATABASE_PORT:
        required: true
      DATABASE_NAME:
        required: true
jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    permissions:
      id-token: write
      contents: read
    steps:
    - uses: actions/checkout@v2
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v2
      with:
        role-to-assume: ${{ secrets.AWS_ECR_ROLE }}
        # not a secret, but you can only configure secrets with the Github Terraform provider,
        # not environment variables.
        aws-region: ${{ secrets.AWS_REGION }}
    - name: Log in to AWS ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v2
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v2
    - name: Docker meta
      id: meta
      uses: docker/metadata-action@v4
      with:
        # list of Docker images to use as base name for tags
        images: |
          ${{ steps.login-ecr.outputs.registry }}/${{ secrets.AWS_ECR_REPOSITORY }}
        # generate Docker tags based on the following events/attributes
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha,format=long
          type=raw,value=latest
    # TODO split out bundle install into separate step that caches in GHA cache,
    # currently it's not cached at all due to multi-stage builds
    - name: Build and push
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        pull: true
        tags: ${{ steps.meta.outputs.tags }}
        build-args: |
          PORT=3030
          ENVIRONMENT=${{ inputs.environment }}
        cache-from: |
          type=gha
          type=registry,ref=${{ steps.login-ecr.outputs.registry }}/${{ secrets.AWS_ECR_REPOSITORY }}:latest
        cache-to: |
          type=gha
        target: server-shrinkwrapped
    # TODO split this into a separate dependent job
    - name: Trigger deploy of ECS service
      env:
        CLUSTER: ${{ secrets.AWS_ECS_CLUSTER }}
        SERVICE: ${{ secrets.AWS_ECS_SERVICE }}
      run: |
        aws ecs update-service --cluster $CLUSTER --service $SERVICE --force-new-deployment
    # This step assumes that the database is accessible from the public internet.
    - name: Run migrations
      env:
        DATABASE_USERNAME: ${{ secrets.DATABASE_USERNAME }}
        DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD }}
        DATABASE_HOST: ${{ secrets.DATABASE_HOST }}
        DATABASE_PORT: ${{ secrets.DATABASE_PORT }}
        DATABASE_NAME: ${{ secrets.DATABASE_NAME }}
        ECR_IMAGE: ${{ steps.login-ecr.outputs.registry }}/${{ secrets.AWS_ECR_REPOSITORY }}:latest
      run: |
        docker run \
          --rm \
          -e RAILS_ENV=${{ inputs.environment }} \
          -e SECRET_KEY_BASE_DUMMY=1 \
          --env-file <(printenv | grep DATABASE_) \
          $ECR_IMAGE \
          bundle exec rails db:setup
